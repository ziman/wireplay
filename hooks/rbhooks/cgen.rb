class CGen
   @@client_code = %Q{/* Autogenerated by Wireplay/cgen on: $DATETIME$ */
/* Wireplay #{Wireplay::WIREPLAY_PROG_VER} */
/* #{Wireplay::WIREPLAY_COPYRIGHT} <#{Wireplay::WIREPLAY_AUTHOR}> */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <assert.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <signal.h>

$PEER_DATA_DEFINITION$

static void sigpipe_handler(int signo)
{
   printf("SIGPIPE: Exiting\\n");
   exit(1);
}

int main(int argc, char **argv)
\{
   int sock;
   struct sockaddr_in sin;
   int ret;
   int flag;
   static char buffer[1500000];

   if(argc < 3) {
      printf("Usage:\\n");
      printf("%s <host> <port>\\n", argv[0]);
      exit(EXIT_FAILURE);
   }

   signal(SIGPIPE, sigpipe_handler);

   sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   assert(sock != -1);

/*
   flag = 1;
   ret = setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void*) &flag, sizeof(flag));
   assert(ret != -1);
*/

   sin.sin_addr.s_addr = inet_addr(argv[1]);
   sin.sin_port = htons(atoi(argv[2]));
   sin.sin_family = AF_INET;

   ret = connect(sock, (struct sockaddr*) &sin, sizeof(sin));
   assert(ret == 0);

   $PEER_DATA_TRANSFER$

   shutdown(sock, SHUT_RDWR);
   close(sock);

   return 0;
\}
}
   def initialize
      @stack = Array.new
   end

   def on_data(w_desc, direction, data)
      #cmsg("CGEN: Received data event")

      case direction
         when Wireplay::REPLAY_SERVER_TO_CLIENT
            if w_desc.role == Wireplay::ROLE_CLIENT
               recv_data(data)
            else
               send_data(data)
            end
         when Wireplay::REPLAY_CLIENT_TO_SERVER
            if w_desc.role == Wireplay::ROLE_CLIENT
               send_data(data)
            else
               recv_data(data)
            end
         else
            # WARNING: Invalid direction
      end

      return nil
   end

   def on_start(desc)
      cmsg("CGEN: Received start event (output file: ./cgen.c)")
   end

   def on_stop(desc)
      cmsg("CGEN: Received stop event")

      cgen_write_to_file("cgen.c")
   end

   private
   def cgen_write_to_file(file)
      send_c = 0
      recv_c = 0

      vars = []
      funcs = []

      @stack.each do |e|
         if e[:type] == "send"
            vname = "c2s_#{send_c}"
            v = blob_to_carray(vname, e[:data])

            vars.push(v)
            funcs.push("send(sock, #{vname}, #{e[:data].size}, 0);")

            send_c += 1
         else
            funcs.push("recv(sock, buffer, #{e[:data].size}, 0);")

            recv_c += 1
         end
      end
      
      code = @@client_code.dup
      code.sub!("$PEER_DATA_DEFINITION$", vars.join("\n"))
      code.sub!("$PEER_DATA_TRANSFER$", funcs.join("\n\t"))
      code.sub!("$DATETIME$", Time.now.to_s)
      
      f = File.open(file, "w")
      f.write(code)
      f.close
   end

   def send_data(d)
      @stack.push({:type => "send", :data => d})
   end

   def recv_data(s)
      @stack.push({:type => "recv", :data => s})
   end

   def blob_to_carray(name, data, width = 20)
      d = data.dup
      s = []
         
      until d.empty?
         td = d.slice!(0, width)
         tdc = ""
         td.each_byte {|b| tdc += "\\x%02x" % [b]}
         s << "\"" + tdc + "\"" 
      end

      return %Q{
static char #{name}[] = \{
   #{s.join("\n\t")}
\};
      }
   end
end

#def cmsg(s)
#end
#c = CGen.new
#c.on_start("aa")
#c.on_data("aa", 1, "aaaa")
#c.on_stop("aa")

# Register
Wireplay::Hooks.register(CGen.new)
